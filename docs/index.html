<!DOCTYPE html>
    <html lang=en>
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

        <title>Avocado</title>

        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link rel="stylesheet" href="css/prettify.css">
        <link rel="stylesheet" href="css/bootstrap.css">
        <link rel="stylesheet" href="css/style.css">
    </head>
    <body>

        <div class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container-fluid">
                    <span class="brand">Avocado <span style="font-size: 15px; color: #999">0.9 Beta</span></span>
                    <ul class=nav>
                        <li><a href="https://github.com/cbmi/avocado/">GitHub Repository</a>
                        <li><a href="coverage/">Code Coverage</a>
                    </ul>
                </div>
            </div>
        </div>

        <nav id=sidebar>


            <h3><a href=#learn>Learn</a></h3>
            <ul class=unstyled>
                <li><a href=#background>Background</a>
                <li><a href=#target-applications>Target Applications</a>
                <li><a href=#types-metadata>Types of Metadata</a>
            </ul>

            <h3><a href=#get-started>Quick Start</a></h3>
            <ul class=unstyled>
                <li><a href=#dependencies>Dependencies</a>
                <li><a href=#download-install>Download &amp; Install</a>
                <li><a href=#configure>Configure</a>
            </ul>

            <h3><a href=#tutorial>Tutorial</a></h3>
            <ul class=unstyled>
                <li><a href=#initialize-metadata>Initialize Metadata</a>
            </ul>

            <h3><a href=#apis>APIs</a></h3>
            <ul class=unstyled>
                <li><a href=#modeltree-integration>ModelTree Integration</a>
                <li><a href=#translators>Translators</a>
            </ul>

            <h3><a href=#the-concept>The "Concept"</h3>
            <ul class=unstyled>
                <li><a href=#concept-model>Concept Model</a>
                <li><a href=#formatters>Formatters</a>
                <li><a href=#exporters>Exporters</a>
            </ul>
        </nav>

        <div id="content">

            <header>
                <img id=logo src=img/avocado.jpg>
                <hgroup>
                    <h1>Avocado</h1>
                    <h3>Metadata management for Django models</h3>
                </hgroup>
            </header>


            <h2 id=learn>Learn</h2>

            <h3 id=background>Background</h3>
            <section class=row>
                <span class=span12>
                    <p>When you create Django models, you supply most
                    of the necessary <strong>structural</strong> metadata for interfacing with them via supported
                    database backends. However, in general, there is no formal mechanism to supply
                    <strong>descriptive</strong> or <strong>administrative</strong> metadata about models. Avocado 
                    is a Django app which provides database-driven metadata management for your models. Sounds exciting, right?</p>
                </span>
            </section>

            <section class=row>
                <span class=span12>
                    <p>Avocado grew out of projects being developed in a clinical research environment where
                    data models can often be large and complex. Additionally, there are frequently database fields that contain
                    related data. When developing applications that make use of such data, developers need to be able to provide
                    end-users with appropriate context and representation of the data elements to avoid confusion and 
                    errors of omission.</p>
                                     
                    <h4>A Real Example</h4>

                    <p>All this abstract talk can make you a little wobbly, so here's a more concrete example: In 
                    medicine, it's typical that results from a diagnostic test like a blood test might be broken into several columns
                    in a relational database: a numerical value, units of measure, and an assessment as to
                    whether it is normal, high, or low. As a developer you'd like to be able to bundle these conveniently
                    in your application. While you could just store them all as one text field in your database, that sacrifices
                    the ability to query and makes mathematical calculations problematic. On the other hand, splitting them apart means
                    a user who doesn't know your data model very well needs to know upfront to hunt down the various elements on their own,
                    or they risk getting an incomplete picture. In addition, you might also want to provide a definition for the measurement as well 
                    as conversions when exporting data for numerical analysis.</p>
                    
                    <p>In many cases, these kinds of complexities result in a research workflow where the technical
                    team act as "keepers of the data", and all the researcher's questions are filtered through them to be
                    translated into queries. This situation, while good for the continued employment of engineers, is not 
                    ideal for open-ended discovery and hypothesis generation by researchers.</p>

                    <h4>Solution</h4>

                    <p>Avocado was designed to support the development of accessible, transparent, data-rich applications
                    by providing several major capabilities:</p>

                    <ul>
                        <li>A formal metadata storage mechanism for managing loose relationships between database fields</li>
                        <li>Robust API's for interrogating metadata</li>
                        <li>Pre-built components for formatting, displaying, and exporting data</li>
                    </ul>
                </span>
            </section>

            <h3 id=target-applications>Target Applications</h3>

            <section class=row>
                <span class=span12>
                    <p>While Avocado can be useful for any project, it's likely to be most applicable to
                    projects with a heavy focus on data, especially ones with query, reporting, and export requirements.</p>
                </span>
            </section>

            <h3 id=types-metadata>Types of Metadata</h3>

            <h4>Structural</h4>

            <section class=row>
                <span class=span12>
                    <p>Django's <a href=https://docs.djangoproject.com/en/1.3/ref/models/fields/>model field reference</a>
                    describes the options available for defining model fields. The field's subclass
                    (e.g. <code>IntegerField</code>) and the various options passed (e.g. <code>null=True</code>)
                    contain structural metadata which can be used to understand a field's constraints.</p>

                    <p>A simple example of how this is useful is to look at how Django's field validation
                    works. If one attempts to save an integer field with a string value, a
                    <code>ValidationError</code> will be thrown complaining about the type. This prevents a downstream database
                    type error.</p>
                </span>
            </section>

            <h4>Descriptive</h4>

            <section class=row>
                <span class=span12>
                    <p>For any medium to large size data model, describing and managing each field can be
                    a painstaking task. Fields and data available to end-users for query and display
                    should be informative. This requires high-quality, descriptive metadata.</p>

                    <p>Django provides two field options <code>verbose_name</code> and <code>help_text</code>
                    that are descriptive metadata, but are hard-coded in the field definition. This is a limitation
                    if that metadata is managed by another party (client or domain expert) since this must be supplied
                    at deployment time instead of runtime.</p>
                </span>
            </section>

            <h4>Administrative</h4>

            <section class=row>
                <span class=span12>
                    <p>For applications which integrate multiple data sources, it can be useful to keep
                    track of the <em>source</em> information, such as a <a href=http://en.wikipedia.org/wiki/Uniform_resource_identifier>URI</a>. Likewise, it may be desirable
                    to restrict access to parts of the data model to certain users, that is, an end-user must
                    be <em>authorized</em> to interact with certain data.</p>
                </span>
            </section>

            <hr>
            <h2 id=get-started>Quick Start</h2>



            <h3 id=dependencies>Dependencies</h3>

            <section class=row>
                <span class=span12>
                    <ul>
                        <li><a href=http://www.djangoproject.com>Django 1.3+</a>
                        <li><a href=https://github.com/cbmi/modeltree>ModelTree</a>
                        <li><a href=http://pypi.python.org/pypi/ordereddict>ordereddict</a>
                            (Python 2.6 only)
                    </ul>

                    <div class="alert alert-block alert-warning">
                        <p>It is assumed <a href=http://www.python.org/download/>Python 2.6+</a> and
                        <a href=http://pypi.python.org/pypi/setuptools>setuptools</a> are already installed.
                        If not, follow the previous two links for download and installation instructions.</p>
                    </div>
                </span>
            </section>

            <h3 id=download-install>Download &amp; Install</h3>

            <section class=row>
                <span class=span12>
                    <p>Stable releases of Avocado are available on
                    <a href=http://pypi.python.org/pypi/avocado>PyPI</a>. Install using
                    <code>pip</code> or <code>easy_install</code>. All dependencies are
                    installed automatically.</p>

                    <h4>Pip</h4>
<pre class=prettyprint>
pip install avocado
</pre>
                    <h4>easy_install</h4>
<pre class=prettyprint>
easy_install avocado
</pre>

                </span>
            </section>

            <h3 id=configure>Configure</h3>

            <section class=row>
                <span class=span12>
                    <p>Since this <em>is</em> about metadata managment, it is highly recommended to have the
                    <a href=https://docs.djangoproject.com/en/1.3/ref/contrib/admin/>Django Admin</a> app
                    installed. Add <code>avocado</code> to your project settings
                    <code>INSTALLED_APPS</code>:</p>
<pre class=prettyprint>
INSTALLED_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.messages',
    'django.contrib.sessions',

    'avocado',
    ...
)
</pre>

                </span>
            </section>

            <hr>


<h2 id=tutorial>Tutorial</h2>


<section class=row>
    <span class=span12>
        <p>We are going to start with two simple models, <code>Author</code> and <code>Book</code>
        in our <code>library</code> app.</p>

<pre class=prettyprint>
# library/models.py
class Author(models.Model):
    name = models.CharField(max_length=100)

class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.ForeignKey(Author)
    pub_date = models.DateField(verbose_name='publication date', null=True)
</pre>
                </span>
            </section>

            <h3 id=initialize-metadata>Initialize Metadata</h3>

            <section class=row>
                <span class=span12>

                    <p>Avocado comes with a <code>sync</code> command which introspects
                    Django models and creates <code>Field</code> instances representing the model fields.
                    At least one app label (<code>library</code>) or model label (<code>library.Book</code>)
                    must be specified.</p>

                    <p>By default, <code>Field</code> instances are not created for primary and foreign
                    key fields. In practice, <em>key</em> fields are used infrequently as is, thus they are
                    not created by default. To override this behavior and include key fields, add the
                    flag <code>--include-keys</code>.</p>

                    <p>Likewise, model fields may be marked as not being <a href=https://docs.djangoproject.com/en/1.3/ref/models/fields/#editable>editable</a> in the model
                        field definitions. This flag is turned on typically for operational or
                        bookkeeping-type fields. By default these fields are not synced either, but
                        can overridden by passing the <code>--include-non-editable</code>.</p>

                    <div class="alert alert-block alert-info">
                        <h4 class=alert-heading>The Admin Works Too</h4
                        Fields not created using Avocado's <code>sync</code> command can be
                        created in the admin interface. This command exists to provide a starting point,
                        getting the bulk of the fields created.
                    </div>

                    <div class="alert alert-block alert-info">
                        <h4 class=alert-heading>Need to Update Existing Fields?</h4>
                        For updating existing <code>Field</code> instances, pass the <code>--update</code>
                        flag when running the command. Note that this will overwrite existing metadata for
                        the field so use with caution.
                    </div>

                    <p>For our purposes here, we can simply do the bare minimum:</p>

<pre class="prettyprint lang-sh">
./manage.py avocado sync library
1 field added for Author
2 fields added for Book
</pre>
                </span>
            </section>

            <h3 id=try-the-api>Field Data Model</h3>

            <section class=row>
                <span class=span4>
                    <p>An Avocado <code>Field</code> represents a single Django model <code>Field</code>
                    instance. It is mapped by defining the following three attributes. These three uniquely
                    attributes identify a model field instance.</p>

                    <ul>
                        <li><code>f.app_name</code> - The name of the app this field comes from
                        <li><code>f.model_name</code> - The name of the model this field is associated with
                        <li><code>f.field_name</code> - The attribute name of the field
                    </ul>

                </span>

                <span class=span8>
<pre class=prettyprint>
&gt;&gt;&gt; from avocado.models import Field
&gt;&gt;&gt; f = Field.objects.get_by_natural_key('library', 'book', 'title')
&gt;&gt;&gt; f
&lt;Field 'library.book.title'&gt;
&gt;&gt;&gt; f.app_name
'library'
&gt;&gt;&gt; f.model_name
'book'
&gt;&gt;&gt; f.field_name
'title'
</pre>

                </span>
            </section>

            <section class=row>
                <span class=span4>
                    <p>Additional metadata can be defined for this object to make it more useful
                    to humans.</p>

                    <ul>
                        <li><code>f.name</code> - A verbose human readable name of the field
                        <li><code>f.name_plural</code> - The plural form of the verbose name. <em>If not
                        defined, an <code>s</code> will be appended to <code>f.name</code> when
                        the plural form is accessed.</em>
                        <li><code>f.description</code> - A long description for the field
                    </ul>
                </span>

                <span class=span8>
<pre class=prettyprint>
&gt;&gt;&gt; f.name = 'Title'
# f.name_plural can be set, but does not need to be since
# this is a simple plural form
&gt;&gt;&gt; f.get_plural_name()
'Titles'
&gt;&gt;&gt; f.description = 'The title of a book'
</pre>
                </span>
            </section>

            <h3 id=try-the-api>Field Instance API</h3>

            <section class=row>
                <span class=span4>
                    <ul>
                        <li><code>f.field</code> - the model <code>Field</code>  instance this field
                        represents
                        <li><code>field.model</code> - the model class this field is associated with
                    </ul>
                </span>

                <span class=span8>
<pre class=prettyprint>
&gt;&gt;&gt; f.field
&lt;django.db.models.fields.CharField at 0x101b5fe10&gt;
&gt;&gt;&gt; f.model
library.models.Book
</pre>

                </span>
            </section>

            <hr>

            <h2 id=apis>APIs</h2>

            <h3 id=modeltree-integration>ModelTree Integration</h3>

            <section class=row>
                <span class=span8>
                    <p>Avocado has integrated support with the
                    <a href=https://github.com/cbmi/modeltree/>ModelTree</a> library. This allows
                    for building queries at runtime using the available metadata.</p>

                    <div class="alert alert-block alert-info">
                        <p>Don't know what ModelTree is? Read the docs
                        <a href=http://cbmi.github.com/modeltree/docs/>here</a>.</p>
                    </div>
                </span>
            </section>

            <h3 id=translators>Translators</h3>

            <section class=row>
                <span class=span4>
                    <p>Translators are used to modify query conditions prior to being executed.
                    Depending on the quality or variability of your data, the query interface for
                    a field may not represent the data 1:1 with the underlying data. Thus the
                    incoming query condition may need to be <em>translated</em> in some way to
                    work with the underlying database.</p>

                    <p>A query condition boils down to a <strong>field</strong>, <strong>operator</strong>
                    and <strong>value</strong>. Avocado implements a set of formal <code>Operator</code>
                    classes that roughly map (but not limited) to Django's
                    <a href=https://docs.djangoproject.com/en/1.3/ref/models/querysets/#field-lookups>field lookups</a>.
                    Each <code>Operator</code> class has an <code>is_valid</code> method that takes a value and
                    checks to see if it makes sense for the chosen operator.</p>

                    <div class="alert alert-block alert-warning">
                        <p>These operator classes perform only light validation of the value
                        to prevent being too restrictive.</p>
                    </div>
                </span>

                <span class=span8>
<pre class=prettyprint>
&gt;&gt;&gt; from avocado.query.operators import registry as operators
&gt;&gt;&gt; iexact = operators.get('iexact')
&gt;&gt;&gt; iexact.is_valid(['hello', 'world'])
False
&gt;&gt;&gt; iexact.is_valid('hello world')
True
&gt;&gt;&gt; inlist = operators.get('inlist')
&gt;&gt;&gt; inlist.is_valid(['hello', 'world'])
True
&gt;&gt;&gt; inlist.is_valid('hello world')
False
</pre>
                </span>
            </section>

            <section class=row>
                <span class=span4>
                    <p>The base <code>Translator</code> class uses
                    <a href=https://docs.djangoproject.com/en/1.3/ref/contrib/forms/api/>Django's Form API</a>
                    to validate and clean the value relative to the underlying model field
                    (e.g. <code>f.field</code>).</p>

                    <p>The primary method to call is <code>translate</code> which calls <code>clean_value</code>
                    and <code>clean_operator</code>.</p>
                </span>

                <span class=span8>
<pre class=prettyprint>
&gt;&gt;&gt; t = Translator()
&gt;&gt;&gt; t.translate(f, 'icontains', 'Python')
{
    'condition': &lt;django.db.query_utils.Q at 0x1027b78d0&gt;,
    'annotations': {},
    'cleaned_data': {
        'operator': 'icontains',
        'value': u'Python',
    },
    'raw_data': {
        'operator': 'icontains',
        'value': 'Python',
    },
}
</pre>
                </span>
            </section>

            <hr>

            <h2 id=the-concept>The "Concept"</h2>

            <h3 id=concept-model>Concept Model</h3>

            <section class=row>
                <span class=span12>
                    <em>To be written..</em>
                </span>
            </section>

            <h3 id=formatters>Formatters</h3>

            <section class=row>
                <span class=span12>
                    <em>To be written..</em>
                </span>
            </section>

            <h3 id=exporters>Exporters</h3>

            <section class=row>
                <span class=span12>
                    <em>To be written..</em>
                </span>
            </section>

        </div>

        <script src="js/prettify.js"></script>
        <script>prettyPrint();</script>
        <script>
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-XXXX-X']);
          _gaq.push(['_trackPageview']);

          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        </script>
    </body>
</html>

